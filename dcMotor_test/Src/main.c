/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


#define GPIOD_ADDR  			0x40020C00
#define RCC_ADDR 				0x40023800
#define RCC_AHB1OFFSET			0x30
#define OUTPUTREG_OFFSET 		0x14    //Output Data register (ODR) offset
#define INPUTREG_OFFSET			0x10    //Input Data register (IDR) offset




int main(void)
{

	uint32_t *pRCCClk = (uint32_t*) (RCC_ADDR + RCC_AHB1OFFSET);
	uint32_t *pGPIOModerReg_output = (uint32_t*) GPIOD_ADDR;
	uint32_t *pGPIODataReg_Output = (uint32_t*) (GPIOD_ADDR + OUTPUTREG_OFFSET);

	uint32_t *pGPIOModerReg_input = (uint32_t*) GPIOD_ADDR;
	uint32_t *pGPIODataReg_input = (uint32_t*) (GPIOD_ADDR + INPUTREG_OFFSET);

	uintmax_t statusReg;

	//ENABLE RCC CLOCK for GPIO-D
	*pRCCClk |= (0x1<<3);

	//SET THE MODER AS OUTPUT AT PIN-8 at 16 bit
	*pGPIOModerReg_output &= ~(0x3<<16);	//Clearing GPIOD pin-8 at 16bit, to 00 by masking 0x11 -> 1111100<16
	*pGPIOModerReg_output |= (0x1<<16);   //then, Setting GPIOD pin-8 at 16 bit, as output mode (01)


	//SET THE MODER AS INPUT AT PIN-9 at 17 bit
	*pGPIOModerReg_input &= ~(3<<0);


	while(1){

		//reading port_d pin-9 status, this will grap the status of pin-9 to check if it is connected to VCC(1) or GND(0).
		statusReg = (uint32_t) *pGPIODataReg_input & 0x2;

		if(statusReg){

			*pGPIODataReg_Output |= (1<<8);
		}
		else{
			*pGPIODataReg_Output &= ~(1<<8);
		}

	}


}







